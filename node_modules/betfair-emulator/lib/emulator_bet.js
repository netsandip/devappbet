'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _ = require('lodash');

var NEXT_BET_ID = 10000000000;

var BET_DEFAULT_OPTIONS = {
    orderType: 'LIMIT',
    persistenceType: "LAPSE"
};

var EmulatorBet = function () {
    function EmulatorBet(logger, selectionId, side, price, size) {
        var opts = arguments.length <= 5 || arguments[5] === undefined ? {} : arguments[5];

        _classCallCheck(this, EmulatorBet);

        var options = _.merge(_.cloneDeep(BET_DEFAULT_OPTIONS), opts);
        if (options.orderType != 'LIMIT') {
            throw new Error('Only orderType="LIMIT" orders are supported');
        }
        this.log = logger;
        this.betId = NEXT_BET_ID++;
        this.orderType = options.orderType;
        this.selectionId = selectionId;
        this.side = side;
        this.limitOrder = {
            price: price,
            size: size,
            persistenceType: options.persistenceType
        };
        this.placedDate = new Date().toISOString();

        this.averagePriceMatched = 0;
        this.sizeMatched = 0;
        this.sizeRemaining = this.limitOrder.size;
        this.sizeLapsed = 0;
        this.sizeCancelled = 0;
        this.sizeVoided = 0;
    }

    // shorthand price getter


    _createClass(EmulatorBet, [{
        key: 'getInstruction',
        value: function getInstruction() {
            return {
                selectionId: this.selectionId,
                limitOrder: this.limitOrder,
                orderType: this.orderType,
                side: this.side
            };
        }
    }, {
        key: 'getOrder',
        value: function getOrder() {
            return {
                betId: this.betId,
                orderType: this.orderType,
                status: this.status,
                persistenceType: this.limitOrder.persistenceType,
                side: this.side,
                price: this.limitOrder.price,
                size: this.limitOrder.size,
                bspLiability: 0,
                placedDate: this.placedDate,
                avgPriceMatched: this.averagePriceMatched,
                sizeMatched: this.sizeMatched,
                sizeRemaining: this.sizeRemaining,
                sizeLapsed: this.sizeLapsed,
                sizeCancelled: this.sizeCancelled,
                sizeVoided: this.sizeVoided,
                isEmulatorBet: true,
                emulatorMatchReason: this.reason
            };
        }
    }, {
        key: 'lapse',
        value: function lapse() {
            this.log.debug('EmulatorBet: lapse:' + this.toString());
            this.sizeLapsed = this.sizeRemaining;
            this.sizeRemaining = 0;
        }
    }, {
        key: 'match',
        value: function match(price, reason) {
            this.log.debug('EmulatorBet: match:' + this.toString() + 'averagePriceMatched:' + price + ' reason:' + reason);
            this.averagePriceMatched = price;
            this.sizeMatched = this.sizeRemaining;
            this.sizeRemaining = 0;
            this.reason = reason;
        }
    }, {
        key: 'cancel',
        value: function cancel(sizeReduction) {
            sizeReduction = parseFloat(sizeReduction);
            this.log.debug('EmulatorBet: sizeReduction:' + sizeReduction + ' bet:' + this.toString());
            var sizeCancelled = this.sizeRemaining;
            if (sizeReduction > 0) {
                sizeCancelled = _.min([sizeReduction, this.sizeRemaining]);
            }
            this.sizeRemaining -= sizeCancelled;
            this.sizeCancelled += sizeCancelled;
            //console.log(`sizeCancelled=${sizeCancelled}`);
            return sizeCancelled;
        }
    }, {
        key: 'toString',
        value: function toString() {
            return this.side + ':' + this.selectionId + ' ' + this.limitOrder.size.toFixed(2) + '@' + this.limitOrder.price;
        }
    }, {
        key: 'price',
        get: function get() {
            return this.limitOrder.price;
        }

        // shorthand size getter

    }, {
        key: 'size',
        get: function get() {
            return this.limitOrder.size;
        }
    }, {
        key: 'status',
        get: function get() {
            return this.sizeRemaining > 0 ? 'EXECUTABLE' : 'EXECUTION_COMPLETE';
        }
    }]);

    return EmulatorBet;
}();

module.exports = EmulatorBet;