'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _ = require('lodash');
var EmulatorMarket = require('./emulator_market.js');

var NETWORK_DELAY = 20; // ms, every API call is delayed this time
var BETTING_DELAY = 50; // ms caused by Malta roundtrip

var Emulator = function () {
    function Emulator(logger) {
        _classCallCheck(this, Emulator);

        this.log = logger;
        this.markets = new Map();
        this.log.debug('Emulator log started');
    }

    // control which markets are emulated


    _createClass(Emulator, [{
        key: 'enableEmulationForMarket',
        value: function enableEmulationForMarket(marketId) {
            this.log.info('started emulation for market: ' + marketId);
            this.markets.set(marketId, new EmulatorMarket(this.log, marketId));
        }
    }, {
        key: 'disableEmulationForMarket',
        value: function disableEmulationForMarket(marketId) {
            this.log.info('stopped emulation for market: ' + marketId);
            this.markets.delete(marketId);
        }
    }, {
        key: 'isEmulatedMarket',
        value: function isEmulatedMarket(marketId) {
            return this.markets.has(marketId);
        }

        // getMarketBook feed, provides prices for emulator

    }, {
        key: 'onListMarketBook',
        value: function onListMarketBook(params, marketBooks) {
            var _this = this;

            this.log.debug('feed feedListMarketBook', marketBooks);
            _.each(marketBooks, function (marketBook) {
                if (!_this.markets.has(marketBook.marketId)) {
                    // skip not emulated markets
                    return;
                }
                var marketEmulator = _this.markets.get(marketBook.marketId);
                marketEmulator.onListMarketBook(params, marketBook);
            });
        }

        // handle orders

    }, {
        key: 'placeOrders',
        value: function placeOrders(params) {
            var _this2 = this;

            var cb = arguments.length <= 1 || arguments[1] === undefined ? function () {} : arguments[1];

            this.log.debug('placeOrders scheduled', params);
            var marketId = params.marketId;
            if (!this.markets.has(marketId)) {
                throw new Error('Market does not use emulator, marketId=' + marketId);
            }
            var market = this.markets.get(marketId);
            if (!market.initialized) {
                console.log('throw error');
                throw new Error('Cannot placeOrders on uninitialized market, marketId=' + marketId);
            }
            var delay = market.betDelay * 1000 + NETWORK_DELAY + BETTING_DELAY;
            _.delay(function () {
                _this2.log.debug('placeOrders delayed execution, delay=' + delay, params);
                market.placeOrders(params, cb);
            }, delay);
        }
    }, {
        key: 'cancelOrders',
        value: function cancelOrders(params) {
            var _this3 = this;

            var cb = arguments.length <= 1 || arguments[1] === undefined ? function () {} : arguments[1];

            this.log.debug('cancelOrders scheduled', params);
            var marketId = params.marketId;
            if (!this.markets.has(marketId)) {
                throw new Error('Market does not use emulator, marketId=' + marketId);
            }
            var market = this.markets.get(marketId);
            if (!market) {
                // no bets to cancel
                _.delay(function () {
                    cb(null, {
                        customerRef: params.customerRef,
                        status: 'SUCCESS',
                        marketId: params.marketId,
                        instructionReports: []
                    });
                }, delay);
                return;
            }
            var delay = NETWORK_DELAY + BETTING_DELAY;
            _.delay(function () {
                _this3.log.debug('cancelOrders delayed execution, delay=' + delay, params);
                market.cancelOrders(params, cb);
            }, delay);
        }
    }]);

    return Emulator;
}();

module.exports = Emulator;